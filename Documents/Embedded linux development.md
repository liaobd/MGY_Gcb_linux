# 嵌入式Linux开发

## 第一部分 Linux基础

Linux版本选择Ubuntu18.04，安装教程：**谷歌搜索**

### 第一章  熟悉Linux系统

Ubuntu18.04安装完成后，为了方便以后在嵌入式移动设备上的开发，必须熟悉Linux系统的使用环境。

**本章内容摘要如下：**

- 熟悉Linux系统，熟悉基本操作，了解相关概念。
- 学会vi/vim编辑器。
- 熟悉shell，学会shell编程。
- 熟悉Makefile，学会make工具构建项目。
- 熟悉Git，学会使用GitHub和Gitee管理项目。



*如何定制自己的Ubuntu与美化系统，最终打造一个MAC风格或其它类型的风格的桌面环境，在另一份教程里提到。*



#### 1.1  开始使用Linux

为什么强调需要在带桌面的图形界面上熟悉Linux系统？

- 将来接触的嵌入式Linux设备开发，是不带图形界面的，甚至连编译代码都系要在PC机上完成。
- 刚从Windows环境转来Linux，这两个系统有相同之处，但不同点也有很多，主要是体现在了操作方式上的不同以及概念上的不同。
- 尽快熟悉使用Linux，尽快投入项目开发环境中去。



##### 1.1.1 嵌入式Linux的相关概念

首先从Linux的使用场景说起。

生活中我们接触得最多的就是手机里的安卓或IOS系统，以及Windows，若不是相关的开发人员，可能都不会听说过Linux，但是Linux系统在生活中其实是随处可见的。我们的手机操作系统就是基于Linux内核开发的，但是不开源，随处可见的移动设备，终端机、服务器，甚至导弹上的控制系统都是基于Linux开发起来的，所以从大方向上划分，Linux系统的应用场景可以分为两类：

- 服务器
- 嵌入式设备(可移动的和不可移动的)

既然Linux系统这么广泛，那与开发它相关的行业有那些呢？

1. 服务器运维：服务器基本都运行在Linux系统上，而管理与开发的从业人员则是服务器运维工程师。

2. 应用软件开发：类似与Windows的QQ、浏览器等等应用软件(application、简称App)，在Linux系统上也有许多应用软件，这些便是由Linux应用软件开发工程师开发的，关于应用软件开发也大致上分为以下三种：

   - 服务器应用软件开发；
   - 桌面应用软件开发；
   - 嵌入式应用软件开发。

   服务器应用软件开发，顾名思义，就是专门在服务器主机上跑的应用软件；桌面应用软件开发，我们平时接触到的电脑都属于桌面系统，是带显示屏的，而我们在桌面系统上运行的应用软件就属于这一类；嵌入式应用软件开发的方向主要是针对设备应用场景做针对性的开发，如扫地机器人、汽车导航仪以及我们公司想要开发的显示屏控制器。**但是十分注意的一个概念是，应用软件开发是不与硬件打交道的，即使是在嵌入式设备上开发APP，与它们打交道的是操作系统，即Linux。操作系统通过开放系统API来完成APP对硬件的特殊控制，或者硬件的数据和信息通过系统API向上提供给APP**

3. 设备驱动开发：本质也属于软件程序，与应用程序不同的是，它是介于硬件和操作系统之间，是硬件与操作系统之间的桥梁；而应用程序是介于人与操作系统之间。简单粗暴的理解则是驱动程序就是STM32裸机开发里的那种设备初始化代码(BSP)，但实际上比裸机开发复杂得多，因为要与操作系统交互。下图显示了这样的层次关系：

![image-20201104140726058](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104140726058.png)

对于不使用操作系统或使用小型实时操作系统（如FreeRTOS）的设备来说，与硬件相关的驱动程序与应用程序往往混合在一起，因此常常不会对驱动与应用进行严格的区分，这也导致更换硬件平台时，应用程序移植困难。

使用了Linux系统的设备，硬件会由操作系统接管。Linux系统的一个重要设计哲学是一切皆文件。包括硬件设备，对于系统来说也是一个文件，所以系统向上层应用程序提供open、write、read、close等统一的文件操作接口，应用程序可以利用这些接口对设备文件进行访问，从而实现对硬件设备的初始化、写入、读取以及关闭等操作。

**当系统接收到应用程序的这些访问请求时，它会向下查询对应设备具体的操作函数，然后调用相应的函数处理请求，而这些针对不同设备具体的操作函数就是设备驱动程序**。因此，设备驱动就是这样一种把硬件与操作系统连接在一起的程序，Linux系统会提供统一的格式，设备驱动开发工程师根据具体的设备按照系统格式要求实现相应的设备操作函数。**由此可见设备驱动开发相比于以往STM32裸机开发的复杂之处**。



##### 1.1.2 Linux的文件系统

相信你在安装完Ubuntu系统后已经开始操作体验了，图形化的界面上操作与Windows有许多相同之处，但是对于第一次使用的用户来说却总是显得那么不习惯，甚至格格不入到最后放弃，这其实都是来源于对未知的恐惧与消极的探索心里，最后放弃探索回到熟悉得不能再熟悉的Windows上找回存在感。

其实只要了解了相关的概念之后，Linux一点也不难，甚至对用户很友好，因为它是可以随意自由搭配与裁剪的，关于如何定制自己的Ubuntu，我在另一份文章里讲解，但是在看那份文章之前，请先把本章看完，熟悉相关概念与操作之后再去看。

**Linux文件系统：** *记住这一点概念，Linux里面一切皆文件，再结合以下讲解来理解*

打开文件夹，显示的目录是主目录，或者换另一种说法：家目录(home)，如下图所示：

![image-20201104150159766](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104150159766.png)

这个目录是当前登录用户的个人目录，用户对于在这个目录之下的所有文件有着一切权利(读改写与删除)，建议在通常情况下个人相关的内容也是保存在该目录中，因为其它目录大都是系统相关的，使用时容易导致混乱，而且需要相关权限。

上面提到的其它目录，如下图黄色方框：

![image-20201104151326387](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104151326387.png)

是在其它位置中的，与家目录区分开来，它叫根目录(root)，这是操作系统管理的目录，对所有用户都开放读权限(基本上)，而操作系统对这个目录下所有的文件拥有一切权利，其它用户包括登录用户需要授权才可以进行某些操作，称为操作受限的。

![image-20201104152009844](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104152009844.png)

根目录下不同的文件有着不同的功能，如bin目录里面存放的是可执行的二进制文件，即应用程序，boot目录存放的是操作系统启动相关的，一旦这个文件被破坏了就会造成操作系统异常，由此可见根目录下文件的重要性，所以这也就是为什么这里的文件对用户只开放了只读功能而不能修改它们，但是用户可以通过根用户授权的方式来进行修改操作，同时这种授权方式也提醒了用户所修改的文件是受保护的文件，应谨慎操作。这种个人与系统文件分割出来的方式大大提升了系统的稳定性与有序性，不容易造成安全隐患与混乱。

与此同时，在根目录下找到home目录，这就是我们所说的家目录，点击进去可以看到里面还有一个文件夹，如图所示：

![image-20201104152814176](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104152814176.png)

这个文件夹是用户目录，由于在我的系统里面只登录了一个用户，所以只有一个，如果有多个用户，就会有多个文件夹，再点进去就是我们的主目录了。

以上概念都是普通的Linux使用者了解了之后即可，但是对于Linux开发者来说，必须要深入了解Linux文件系统这一概念，这是因为在以后的系统移植中，需要构建这种文件系统。

**那么什么是Linux文件系统呢？**

如果从专业的角度说起会觉得晕头转向不知所云，那么便从简单说起，在上面的介绍中，我们知道了Linux最底层的目录是根目录，根目录之下有许多目录，如bin、root、etc、home等等，这是倒数第二层，而这一层除了home目录之外，都是系统运行或应用程序所组成的文件，暂时知道这些即可。再回头看home目录，我们知道它是属于用户的家目录，但是实际上现在的操作系统都是多任务多用户的操作系统，即系统使用者不仅仅只有一个而是可以有多个，关于多用户多任务操作系统这涉及另一个概念，现在只要知道即可，所以在home目录下应该有多个用户相关的目录，一个用户从属于一个目录，到了这里可以理解为第三层，对于这个home目录下的文件，当前登录用户只对它自己的目录有着至高无上的权利，而对其它目录都只能只读无法做其它操作，所以进入到自己对应的主目录后，这里理解为第四层，也就是普通Linux使用者平时接触得最多的一层。

以上按层次的分析很像一个倒着的树状结构，于是乎我们称之为目录树，这个目录树下每个目录或者说文件夹具体是什么内容，属于谁的，是做什么的，可不是随便定制的，它是由Linux文件系统规定的。Linux为了方便管理系统各个资源，制定了这么一套标准，用来说明这个目录必须得是这样的，那个目录必须得是那样的，比如boot必须得是存放与系统启动相关的东西，其它无关的东西不要放进来，而且连目录名字都不能乱取。

Linux文件系统，又称为文件层次标准(FHS)，是Linux系统为方便统一管理资源与文件而定制的标准，在Linux系统中，即使是硬件设备，也是被抽象成了文件，存放在根目录下的dev目录里面，这就对应上了在Linux里面一切皆文件的概念。

关于Linux层次标准这个文档，在Linux基金会官网可以下载，但是有五百多页，以下将简要列一个表格，介绍每个目录的内容与作用：

| 目录        | 内容                                                         |
| ----------- | ------------------------------------------------------------ |
| bin         | 存放系统命令的目录，二进制应用程序，如cd、ls、pwd等          |
| boot        | 存放开机启动过程所需的内容                                   |
| dev         | 所有设备文件的目录                                           |
| etc         | 系统的主要配置文件                                           |
| home        | 用户目录                                                     |
| lib         | 存放sbin和bin目录下命令所需的库文件                          |
| lib32/lib64 | 存放二进制函数库                                             |
| lost+found  | 在EXT3/4系统中，当系统意外崩溃或意外关机时，会产生一些碎片文件在这个目录下面，系统启动fcsk工具会检查这个目录，并修复已损坏的文件。 |
| media       | 用于挂载光盘或U盘                                            |
| mnt         | 与media一样                                                  |
| opt         | 第三方软件安装存放目录                                       |
| proc        | 进程以及内核信息存放目录，不占用硬盘空间                     |
| root        | root用户的目录                                               |
| run         | 是一个临时文件系统，存储系统启动以来的信息，当系统重启时，这个目录下的文件应该被删掉或清除。 |
| sbin        | root用户使用的命令存放目录                                   |
| srv         | 一些网络服务所需要的数据文件                                 |
| sys         | 同proc目录，用于记录CPU与系统硬件相关的信息                  |
| tmp         | 程序运行时产生的临时文件存储目录                             |
| usr         | 系统存放程序的目录                                           |
| var         | 存放内容经常变动的文件目录，如日志                           |

**Linux文件类型**

在Linux下，一切皆文件，但是文件是有类型区别的：

- 普通文件：文本文件、bin文件；
- 可执行文件：脚本、应用程序；
- 链接文件：类似于Windows里的快捷方式，链接文件又分为两类：
  - 硬链接：同一个文件的不同别名；
  - 软链接：链接文件里包含另一个文件的位置信息。
- 目录文件：Linux下一切皆文件，所以目录是文件也就不奇怪了；
- 设备文件：通过打开对应的设备文件可以初始化设备，部分设备还可以通过读写设备文件实现对硬件的控制。

文件有那么多类型，那怎么区分呢？

在Windows里面我们区分文件类型一般是通过文件扩展名来区分，如.exe结尾的是可执行文件。Linux下没有这个要求，但是为了兼容Windows的操作习惯，Linux也可以加入文件扩展名来区分文件类型：

- 后缀.tar、.tar.gz、.tgz、.zip、.tar.bz表示压缩文件，创建命令一般为tar，gzip，zip等。 在压缩文件中的后缀名来通常表示自身由什么压缩格式打包的，以便解压时方便选择要使用的命令。
- .sh表示shell脚本文件，通过shell语言开发的程序。
- .py表示python语言文件，通过python语言开发的程序。
- .html、.htm、.php、.jsp、.do表示网页语言的文件。
- .conf表示系统服务的配置文件。
- .deb表示deb安装包文件。



##### 1.1.3 多用户与文件权限

在早期的Windows操作系统，如Windows 95 和 Windows XP，都是单用户操作系统。 所谓的单用户操作系统，就是说在同一时间，只能由一个用户独自享用系统的全部硬件和软件资源。 我们现在所使用的win7、win8以及win10都是多用户操作系统，与单用户操作系统恰恰相反， 它支持多个用户能够同时访问和使用同一台计算机的全部硬件和软件资源。

在众多用户中，其中的一个用户administrator具有管理其他用户账号和计算机的全部资源的权限。 我们在安装软件的时候，经常会看到“要以管理员身份运行该软件”，又或者是如下图，实际上就是要求我们给予程序一些管理员的权限。

![image-20201104161146798](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104161146798.png)

Linux操作系统，同样也是多用户操作系统，其中具有管理其他用户和计算机的全部资源的用户，称为root。前面提及过安卓系统，实质上也是基于Linux，安卓手机上常常提到的root权限，也就是获取最高的权限， 就跟电脑获取超级管理员的权限是一样的。

在Linux中，每个用户都有一个特定的编号—UID，它是用于标识一个系统用户。Linux将标号0分配给root，它可以分配给每个用户不同的权限，因此每个用户可进行的操作也不同。

在命令行中输入`id`，可以查看当前用户的UID，如下图所示(按住ctrl+alt+t打开命令行)：

![image-20201104161728119](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104161728119.png)

红框是用户的id，可以看到其值为1000，这是root分配的id号，而黄色方框的gid用于标识当前用户所在的分组（Group），每个用户可以对应多个分组，就比如一个人在学校里面既可以属于学生会组织，也可以属于街舞社、绘画社等等。Linux系统拥有多个分组，每个用户分组就相当社团，用户如果是多个用户组的成员，就可以访问其他分组对应的文件， 前提是该分组的文件允许其他用户访问，这就需要了解另一个概念：文件权限。

在Windows系统中我们经常接触的文件属性，无非就是以下两种属性：只读、隐藏。从字面上的意思，我们也很好理解。具有只读属性的文件，我们不能对文件的内容进行修改。而具有隐藏属性的文件，我们一般情况下是看不到的。

Linux的文件属性，可以分为读权限、写权限、执行权限。读权限以及写权限，基本上和Windows操作系统是一样的。关于执行权限，是指可以加载到内存中，并由操作系统加载程序执行的文件。在Windows操作系统中， 我们接触最多的应该是后缀为.exe的文件。但是对于Linux来说，它并不是通过后缀名来识别文件类型的， 如果我们想要执行某个可执行文件，则需要为其添加执行权限，即勾选前面的“允许作为程序可执行文件”。

![image-20201104162709833](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104162709833.png)

除此之外，关于Linux文件权限，还需要分三种情况：文件拥有者（owner），分组成员（groups）以及其他分组成员（other）。 如上图中的文件拥有者我，即当前登录用户对该文件的内容可以进行读写操作， 而对于当前登录用户分组以及其他分组的用户则只能阅读该文件，并不能对该文件进行修改。 如果我们想修改其他分组的文件，我们可以修改该文件分组所拥有的权限。



#### 1.2 开始使用命令行

上面的介绍都是以图形桌面的方式来介绍的，可以看到图形桌面对用户很友好而且也很方便使用，但是为什么还需要熟悉使用这种这么**不方便的‘(?)’**命令行操作呢？

- 在Linux系统里面有很多程序不提供界面操作，为了使用它们只能通过命令行方式；
- Linux文件权限的限制，图形界面的操作只能操作有限的事物，而命令行的方式通过使用根用户权限来操作一切；
- 在以后的开发中，嵌入式平台不提供界面操作，为了尽快融入开发环境，必须的熟悉命令行操作。

以上的三点原因可能不完善，因为在Linux里面使用命令行的理由实在太多了，除此之外，命令行即终端，两者意思一样，英文叫terminal，所以称呼为终端更合适！

在第一句话中，我在不方便后面打了个问号，实际上不方便只是相对的，在熟悉使用了Linux之后，这种不方便的感觉便会消失，实际上操作Linux系统，终端操作是最方便而且效率是最高的！



##### 1.2.1 终端的概念

早期的Unix系统与用户就是通过Shell进行交互的，如下图所示，Shell对外接受用户输入的命令， 对内通过“系统调用”传递给内核，内核执行操作后把输出通过Shell呈现给用户，也就是说， Shell就是一个中间人。而Shell的英文原意“壳”，也是为了把它与内核区分开来。

![image-20201104164916337](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104164916337.png)

那么上面的shell与终端有什么关系呢？

实际上新学者很容易误解为shell就是终端，其实严格意义上，它们有着各自的概念：

- shell：指命令行解释器，常见的解释器有bash、sh、dash等等，在Ubuntu系统中默认用的是bash解释器，所以有时说bash也是指命令行。
- 终端：通常指用来运行Shell的程序。



##### 1.2.2 终端的使用

在Linux系统中，打开终端有两种方式：

- 快捷键`ctrl + alt + t`即可打开，这种打开方式终端会默认定位到用户主目录；
- 鼠标右键选择打开(如下图所示)：这种打开方式可以在任意文件夹下都可以使用，而且在不同的文件夹下打开终端后会自动定位到该文件夹的路径，在桌面打开的话会默认定位到用户主目录。

![image-20201104165748468](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104165748468.png)

**命令提示符：**如图所示

![image-20201104165922217](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104165922217.png)

打开终端后，我们可以看到终端本身显示了一行字符，而且按回车后会重复出现：

实际上这行提示符分成以下几个部分：

- lbd：“@”符号的左侧，它表示的是当前登录用户；
- @：分隔符号，可理解为at，表示lbd用户在主机上登录；
- lbd-Gcb：当前系统的主机名；
- 冒号：分隔符；
- ~：冒号后表示用户当前所在的目录，此处的波浪线表示当前用户的家目录，即“~”的含义为/home/lbd目录；
- $：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是“#”，如果是普通用户，提示符就是“$”。

**开始使用：**

请亲自尝试在终端中输入如下命令，注意如果使用了中文输入法的话，要记得把它切换回英文模式。 另外，在以下命令中的波浪号“~”也是英文符号，还要注意终端中所有的内容都是区分大小写的：

```shell
cd /home	 # 切换到/home目录
pwd				   # 显示当前目录
cd ~				 # 切换至~目录
pwd
ls						# l是字母L的小写，不要把l输入成数字1或字母i的大写
ls -l
```

输入后的结果如下：

![image-20201104171802228](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104171802228.png)



##### 1.2.3 常用命令与帮助

通过以上的一些命令示例，我们大致可以归纳命令的格式：

```shell
command [-optional] [arguments]
```

命令的组成一般分三部分，每部分之间使用空格隔开，说明如下：

- command：命令名，如前面的cd命令，pwd命令，ls命令；
- -optional：命令的选项，使用“-”开头的或“–”开头，如前面示例“ls -l”中的-l选项， 命令会根据具体的选项执行不同的操作。使用“-”时一般是选项的简写， 一些选项可以同时使用，“ls -la”等价于“ls -l -a”，即同时使用“l”和“a”选项。 而“–”一般后面带选项的全名，如“ls -a”等价于“ls –all”；
- arguments：命令参数，如前面cd命令中以“/home”和“~”参数作为路径名。

*注意：以上的中括号代表的是可选的，即不是必要输入的！！！*

那么Linux命令有那么多，还有选项，有着许多种组合，这实在难以记忆，怎么可能方便使用呢？

其实可以灵活使用终端的帮助功能：

1. 每个命令都会带有一个“-h” 或者“–help”的参数，可以用来打印一些帮助说明。 比如，如果现在不知道ls的选项a有什么用法，那么就可以执行下面的命令：

   ```shell
   ls --help
   ```

   ![image-20201104172558665](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104172558665.png)

   从上图中圈出来的地方，可以知道参数a可以只列出隐藏的内容。

2. 灵活使用Tab键自动补全，假如我们知道有个命令是以“whic”开头，但想不起全称， 那么我们可以在终端输入“whic”然后按一下“Tab”键，它会自动补全命令为“which”。如果我们只记得命令是以“wh”开头的话，按一下“Tab”键发现它没反应（如果接入了耳机可以听到一下提示音），这时我们尝试按两下“Tab”键，终端输出了好多以“wh”开头的命令，如which，who，whoami等。所以按一下“Tab”键时如果只有一个匹配的内容时它会自动补全，按两下“Tab”键则会列出所有的匹配项。“Tab”键除了用来补全命令名，还可以自动补全路径，如我们使用cd命令输入“/home”参数时， 先输入“/ho”然后按下“Tab”键，它会把“/ho”自动补全为“/home”路径名，如下图所示。这在使用命令行时是频繁使用的技巧，能减少我们的输入，而且不容易出错。

3. 在应用中我们有时会想要中止命令的执行，或者命令输入到一半的时候觉得输错了不想继续， 这时我们都可以通过“Ctrl”+“c”的组合键来结束。

4. 使用man命令。除了–help选项外，Linux还提供了一个man命令，可用于查看Linux系统自带的参考手册，该手册包含非常丰富的内容， 甚至在我们进行编程开发时还可以使用它来查看函数的接口。

   其使用格式为：

   ```shell
   man [要查询的内容]
   如：
   man ls
   ```

   ![image-20201104173626557](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201104173626557.png)

   按键盘方向键的“↑”“↓”键可以实现画面上下滚动，按键盘的“Page Up”和“Page Down”键可以上下翻页，按“q”键退出手册。

   关于man手册本身的使用，可以使用如下命令查看：
   
   ```shell
   man man 
   ```
   
   ![image-20201105090220647](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201105090220647.png)
   
   从上图可了解到，除了Shell命令外，还可以看到man手册支持共9种类型的内容，如第一章是关于Shell命令， 第二章是系统调用（内核提供的函数）、第三章是库调用（程序库中的函数）等等。
   
   以下表格列出一些常用命令以及它的使用说明：
   
   | 命令  | 使用说明与格式                                               |
   | ----- | ------------------------------------------------------------ |
   | cd    | cd [目录名]：切换目录使用                                    |
   | mkdir | mkdir [-p] 目录名                                            |
   | touch | touch 文件名                                                 |
   | ls    | ls [选项] [目录]                                             |
   | cat   | cat 文件名                                                   |
   | echo  | echo命令的功能是在终端上打印一段文字，也可以把终端 的变量内容打印出来 |
   |       |                                                              |
   |       |                                                              |
   |       |                                                              |
   
   

#### 1.3  软件安装与管理

首先理解软件安装的几个概念：

- 二进制文件安装；
- 源码编译安装；
- 自动化工具安装

在windows操作系统中，我们要想安装某个软件的时候，只要点开相应的exe文件，一直按“下一步”，最后点“完成”， 这样就可以在我们电脑上使用这个软件了。而在Ubuntu系统中提供了一个软件商店，虽然它也可以提供软件的下载， 并且能够自动安装，但是有些软件并不一定能够在里面搜索得到，那只能以源码的方式来安装软件。采用源码的安装方式， 都需要检测当前的系统环境，设置编译的参数，如加入/剔除某个模块等，这样的安装方式就显得非常的繁琐。

目前，大多数类Unix 操作系统都提供了一种中心化的机制用来搜索和安装软件，软件开发者先在固定的硬件平台上将需要安装或升级的软件编译好， 然后再将软件的所有相关的文件打包存放在公开的服务器中。用户想要安装某个软件时，通过包的形式进行分发，包提供了操作系统的基本组件， 以及共享的库、应用程序、服务和文档，当用户需要时，可以运行特定的指令来安装。负责这部分工作内容的工具被称为包管理工具， 包管理工具除了安装软件外，它还负责更新已经安装的包。

在Linux操作系统中，最常见的两种包分别是deb和rpm。



#### 1.4 使用文本编辑器vi/vim





#### 1.5 熟悉shell与shell编程





#### 1.6 使用make工具构建项目

为什么要学习make？

原因：uboot、Linux内核、自己编写的驱动程序等等，有许多源文件，这些源文件如果自己一个一个手动编译和链接，绝对能累死，这时候我们就需要一种自动化的构建工具，这种工具能根据我们的要求来编译链接然后生成可执行文件，所以make就出现了。事实上，在Windows系统开发项目的时候使用的那些IDE，也叫集成开发环境，可以很方便的帮我们管理项目，自动编译文件，而用户只需要关心代码即可，但是IDE的本质也是像make工具一样在帮我们工作，只不过IDE有着友好的图形界面，自动的帮助我们配置好编译环境。那么为什么到Linux下开发就不用IDE了呢？**因为没有**，其实大多数IDE都是收费的，Linux的宗旨就是开源免费，收费的IDE与免费开源的理念不同导致它们走不到一块去，所以Linux上面就没有这些好用的IDE了。

*注意，以上对Linux没有IDE只是片面的理解，事实上还是有的，只是这些IDE不遵循Linux社区的开源协议，它们发布的程序是以二进制格式文件发文的，Linux软件仓库里有四种发布软件的协议，正如我在本章1.3小节所述那样，现在介绍这些只是说明为什么要用make而已，不要太往这方面纠结！！！*

现在知道了必须要使用make工具的原因了，再补充一点，学习make工具是非常有必要而且很有用的，作为对程序员来说是一个知识层次上的升华，可以深入了解编译器工作的原理。

既然如此，在学习make工具之前，首先深入了解一下一个C语言源文件是怎么被编译成一个二进制的可执行文件的就很有必要了！



##### 1.6.1  GCC与Hello World！

**什么是GCC？**

你可能或多或少听过这个名称，在接下来的讲解之前先介绍一下GCC。

GCC(GNU Complier Collection)是一套编译工具链，是指以GCC编译器为核心的一整套工具，用于把代码转化成可执行应用程序，它主要包含以下三部分内容：

- gcc-core：即GCC编译器，用于完成预处理和编译过程，例如把C代码转换成汇编代码。
- Binutils：除GCC编译器外的一系列小工具包括了链接器ld，汇编器as、目标文件格式查看器readelf等。
- glibc：包含了主要的 C语言标准函数库，C语言中常常使用的打印函数printf、内存分配函数malloc就在glibc 库中。

一般而言，常常用GCC编译器指代整套GCC编译工具链，下文中除非特别说明，否则GCC指的就是GCC编译工具链。

**GCC编译器**

GCC编译器是由 GNU 开发的编程语言编译器。 GCC最初代表“GNU C Compiler”，当时只支持C语言。 后来又扩展能够支持更多编程语言，包括 C++、Fortran 和 Java 等。 因此，GCC也被重新定义为“GNU Compiler Collection”，成为历史上最优秀的编译器， 其执行效率与一般的编译器相比平均效率要高 20%~30%。

GCC的官网地址为：https://gcc.gnu.org/，在Ubuntu系统下系统默认已经安装好GCC编译器，可以通过如下命令查看Ubuntu系统中GCC编译器的版本及安装路径：

```shell
gcc -v              #查看gcc版本
which gcc     #查看gcc的安装路径
```

![image-20201108133015465](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108133015465.png)

图中三个方框信息说明如下：

- 红色方框：“Target：x86-64-linux-gnu”表示该GCC的目标平台为x86_64架构（Intel、AMD的CPU）， 表示它编译生成的应用程序只适用于x86架构，不适用于ARM开发板平台；

  *题外话：x86-64架构又称为amd64，原因是这个架构是由AMD公司开发的，一般情况下称为x86-64架构，但是Ubuntu系统里面习惯用amd64，两者是一样的东西，不要迷惑！！！*

- 蓝色方框：“Thread model：posix”表示该GCC遵循posix标准，可以在posix接口上的系统运行；

  *题外话：posix是一个较高层次的概念，它是一套计算机系统的标准，遵循这套标准的计算机具有良好的跨平台特性，暂时知道这些即可，不要太去深究，这是大公司的架构师和系统工程师的工作！！！*

- 黄色方框：“gcc version 7.5.0”表明该GCC的版本为7.5.0，部分程序可能会对编译器版本有要求，比如编译指定版本的uboot、Linux内核的时候可能会对GCC有版本要求。

**Binutils工具集**

Binutils(bin utility)，是GNU二进制工具集，通常跟GCC编译器一起打包安装到系统，它的官方说明网站地址为：https://www.gnu.org/software/binutils/。

在进行程序开发的时候通常不会直接调用这些工具，而是在使用GCC编译指令的时候由GCC编译器间接调用，下面是其中一些常用的工具：

- as：汇编器，把汇编代码转换为机器码(二进制文件，也叫目标文件)；
- ld：链接器，把汇编器生成的多个目标文件组织成最终的可执行程序文件；
- readelf：用于查看目标文件或可执行程序文件的信息；
- nm：用于查看目标文件中出现的符号；
- objcopy：可用于目标文件格式转换，如.bin 转换成 .elf 、.elf 转换成 .bin等；
- objdump：可用于查看目标文件的信息，最主要的作用是反汇编；
- size：可用于查看目标文件不同部分的尺寸和总尺寸，例如代码段大小、数据段大小、使用的静态内存、总大小等。

**glibc库**

glibc库是GNU组织为GNU系统以及Linux系统编写的C语言标准库，因为绝大部分C程序都依赖该函数库，该文件甚至会直接影响到系统的正常运行，例如常用的文件操作函数read、write、open、打印函数printf、动态内存申请函数malloc等。

在Ubuntu系统下，libc.so.6是glibc的库文件，可直接执行该库文件查看版本，在主机上执行如下命令：

![image-20201108134909752](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108134909752.png)

图中蓝色方框表示本系统中使用的glibc是2.27版本，是由GCC 7.3.0版本的编译器编译出来的。

学习C语言的时候，可能有人特别好奇printf、malloc之类的函数是如何实现的， 但是在Windows下的C库是不开源的，无法查看，而在Linux下， 则可以直接研究glibc的源代码，甚至加入开发社区贡献自己的代码，glibc的官网地址为： https://www.gnu.org/software/libc/ ，可在该网站中下载源代码来学习。

**第一个程序Hello World!**

在目录<u>/home/lbd/repo/MGY_Gcb_linux/linux_ws/1_hello_world</u>下面创建一个`hello_world.c`文件，并且编辑内容如下：

```c
#include <stdio.h>

int main()
{
    printf("Hello world!\r\n");
    return 0;
}
```

这是一个非常通用的C Hello World代码，在Windows下和Linux下并没有什么区别， 甚至跟STM32的裸机代码差异也不大，只是在MCU平台下会多了一些硬件初始化的内容。

**编译并执行**

Ubuntu默认安装GCC编译工具链，写好程序后可以直接进行编译，在程序`hello_world.c`的目录下打开终端，执行以下指令：

```shell
gcc hello_world.c -o hello             #使用gcc编译器将C语言文件编译成可执行文件hello
ls                                                                #查看当前目录下的内容
```

完成之后你会发现在当前目录下多了一个hello的文件，这是一个可执行文件，使用命令`./hello`运行它，‘.’代表当前目录，所以当我们想运行一个可执行程序的时候，输出它的路径名即可执行。

*注意：如发现提示无法执行，这是因为该文件没有赋予执行权限，使用命令`chmod u+x hello`赋予它执行权限，但是这个一般很少出现！！！*

**以上是在x86-64平台下编译运行的程序，现在来演示一下在ARM平台上执行同样的步骤！**

首先检查一下开发板平台上有没有安装gcc，若没有则通过以下命令安装：

`sudo apt install gcc -y`

与前面介绍的Ubuntu中GCC不一样的是，开发板中gcc编译工具链的目标平台是arm架构的，表示它生成的应用程序只能运行于ARM平台的开发板， 而不适合用于X86平台。

运行命令`gcc -v`查看版本信息：

![image-20201108152239777](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108152239777.png)

从图中红色方框看出，它默认安装的是`arm-linux-gnueabihf`的gcc编译器，即你在什么平台上下载安装的gcc，它会根据不同平台来安装不同版本，而关于这些版本之间的区别以及这些关键名词的说明在下面介绍，现在先不要纠结。

同理，现在在用户目录下创建一个工作目录：`/home/debian/linux_ws/1_hello_ws`，然后使用vim编辑器编辑：`vim hello_world.c`

*如果提示没有vim编辑器，则执行sudo apt install vim -y来安装，我推荐使用vim而不用vi的理由是，vi这个编辑器我也用不好，建议新手不要浪费时间去折腾这个编辑器，它们两者之间的区别我在本章1.4小节已经介绍了！！！*

内容和前面的一样！

与前面一样编译并执行，你会发现运行结果都是一模一样的，当然这么说似乎有点卖关子。以下对GCC编译过程进行讲解：

**GCC编译过程**

刚刚我们使用gcc命令来编译了一个C语言源文件，现对使用的语法进行讲解：

语法的格式如：gcc [选项] 输入的文件名

常用选项如下：

- -o：小写字母“o”，指定生成的可执行文件的名字，不指定的话生成的可执行文件名为a.out；
- -E：只进行预处理，既不编译，也不汇编；
- -S：只编译，不汇编；
- -c：编译并汇编，但不进行链接；
- -g：生成的可执行文件带调试信息，方便使用gdb进行调试；
- -Ox：大写字母“O”加数字，设置程序的优化等级，如“-O0” “-O1” “-O2” “-O3”， 数字越大代码的优化等级越高，编译出来的程序一般会越小，但有可能会导致程序不正常运行。

若不了解程序的编译过程，那么GCC的编译选项会让人一头雾水。下面以X86_64平台下Ubuntu的编译过程为例进行初步讲解， ARM平台下Debian的编译过程也是类似的，不再进行分析。

GCC编译选项除了-g和-Ox选项，其它选项实际上都是编译的分步骤，即只进行某些编译过程。

```shell
#直接编译成可执行文件
gcc hello_world.c -o hello

#以上命令等价于执行以下全部操作
#预处理，可理解为把头文件的代码汇总成C代码，把*.c转换得到*.i文件
gcc –E hello_world.c –o hello_world.i

#编译，可理解为把C代码转换为汇编代码，把*.i转换得到*.s文件
gcc –S hello_world.i –o hello_world.s

#汇编，可理解为把汇编代码转换为机器码，把*.s转换得到*.o，即目标文件
gcc –c hello_world.s –o hello_world.o

#链接，把不同文件之间的调用关系链接起来，把一个或多个*.o转换成最终的可执行文件
gcc hello.o –o hello
```

GCC 编译工具链在编译一个C源文件时需要经过以下 4 步：

1. 预处理，在预处理过程中，对源代码文件中的文件包含(include)、 预编译语句(如宏定义define等)进行展开，生成.i文件。 可理解为把头文件的代码、宏之类的内容转换成更纯粹的C代码，不过生成的文件以.i为后缀。
2. 编译，把预处理后的.i文件通过编译成为汇编语言，生成.s文件，即把代码从C语言转换成汇编语言，这是GCC编译器完成的工作。
3. 汇编，将汇编语言文件经过汇编，生成目标文件.o文件，每一个源文件都对应一个目标文件。即把汇编语言的代码转换成机器码，这是as汇编器完成的工作。
4. 链接，最后将每个源文件对应的.o文件链接起来，就生成一个可执行程序文件，这是链接器ld完成的工作。

以hello_world.c为例，后面括号代表的是gcc的参数，分步骤编译过程如下图所示。

![image-20201108153352867](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108153352867.png)

关于编译原理，我推荐学有余力(如果你想技术更上一层楼)的读者去阅读《编译原理》这本书，如下图所示：

![image-20201108191239751](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108191239751.png)

这本书非常经典，也是我大学期间看了好久的一本书，此外，对于计算机体系结构以及计算机系统原理等等，推荐阅读这本书《深入理解计算机系统》，如下图所示：

![image-20201108191413848](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108191413848.png)

这也是非常经典的讲解计算机体系结构和操作系统的书籍，至今影响深远，称之为程序员的宝典都不为过！

本小节在这里只是引入门性质的介绍，推荐使用刚刚介绍的那几个命令把hello_world.c这个文件都操作一遍，并尝试阅读得出来的文件有什么不一样，由于篇幅太长，就不展开介绍了。



##### 1.6.2 ARM-GCC

本小节为了展示不同体系结构之间的差异，将在x86-64下编译的hello_world程序拷贝到开发板上运行，看看会有什么差异，因此需要先做以下环境搭建的工作。

**网络文件系统**

又称为NFS(Network File System)，它是一种轻量级的以服务器-客户端为架构的文件传输系统，只用于局域网，一般用来架设企业的文件传输系统。

开启了NFS服务后，客户端访问服务器共享的文件时如同访问本地存储器（磁盘/SD卡/NAND FLASH等）上的文件一样，对于上层应用来说没有任何差别，在嵌入式开发时，我们常常利用这个特性在主机上共享文件，主要应用场景如下：

- 在NFS服务器上编译应用软件，客户端（开发板）通过NFS访问并运行应用程序进行测试；
- 把NFS作为根文件系统来启动。

在后面的实验中，我们常常通过NFS给开发板共享开发主机编写的应用程序，本节内容将介绍如何在开发板和开发主机之间共享目录。我们要构建的使用NFS文件系统的实验环境架构如下图所示。

![image-20201108193654910](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108193654910.png)

在这样的环境中，开发板与开发主机接入到同一个局域网中，然后开发主机 提供NFS服务，开发板通过NFS与开发主机连接共享文件。开发主机生成的目标板应用程序放在NFS的共享文件夹内，开发板访问该文件夹执行应用程序进行测试。

**搭建NFS环境**





##### 1.6.3 make与Makefile

前期铺垫了这么多内容，终于到我们的重头戏--make了，这是本章的重点与难点之一，没有接触过make工具的读者，建议反复阅读本小节与动手做实验，思考与做笔记，因为make涉及概念比较多，语法也大多都是晦涩难懂。

**那么什么是make，而说起make时又常常提起的Makefile又是什么呢？**

首先回顾我们之前讲的hello_world程序，编译的时候我们是通过在终端手动输入命令`gcc hello_world.c -o hello`这样的方式得到可执行文件的，这么看也没什么不妥，也很方便。

但是，前面的问题是只有一个C语言文件，当然无伤大雅，此时如果有五个文件要编译呢？对于勤劳的程序员来说，五个也没事，那一百个呢？此时手动编译这么多文件，是不是傻眼了，实话说，谁真的老老实实动手编译了这一百个文件，那他一定是个混子，上班时间都被这样打发掉了！对于我们后期的项目，uboot，Linux内核，以及各种驱动程序和qt程序，文件何止一百，所以make工具就是来解决这种困难的。

**make是一种自动化构建工具，它可以帮助我们找出项目里面修改变更过的文件，并根据依赖关系，找出受修改影响的其他相关文件，然后对这些文件按照规则进行单独的编译，这样一来，就能避免重新编译项目的所有的文件。那么Makefile就是记录了这些规则与编译依赖的文件，我们在其中合理地定义好文件的依赖关系之后，make工具就能精准地进行编译工作。**

它们的关系如下：

![image-20201108201430283](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108201430283.png)

从上面的介绍，大家可以知道，我们管理一个项目工程，实质上就是管理项目文件间的依赖关系。 所以我们在学习和使用Makefile的时候，一定要牢牢抓住它这种面向依赖的思想， 心里一定要谨记，**Makefile中所有的复杂、晦涩的语法都是更好地为解决依赖问题而存在的**。 理解了它的本质目的之后，我们以后在学习它的过程中就不用死记硬背各种语法了， **只要想想这个本质目的，你会觉得一切都是那么地顺理成章**。

是否真正驾驭Makefile的标志，就在于脑海中是否清晰地知道目标和依赖的关系。当你的大脑能够像make工具一样， 准确无误地解释执行Makefile的时候，就是一个Makefile高手了。我们就是要奔着这个目标去的。

这里再多介绍一下，当工程复杂度再上一个台阶的时候，会觉得手写Makefile也很麻烦， 那个时候可以用CMake、autotools等工具来帮忙生成Makefile。实际上Windows系统下很多IDE工具内部也是使用类似Makefile的方式组织工程文件的， 只不过被封装成图形界面，对用户不可见而已。

**前面大概介绍了make，我们知道了它是根据Makefile来工作的，所以学习的重点就是Makefile**

下图展示了Makefile在底层的编译机制与我们的项目直接怎么挂钩的：

![image-20201108202045754](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108202045754.png)

接下来我们先整体了解Makefile的相关语法，这里要提前跟大家说清楚一点，Makefile经过多年发展，虽然功能非常强大， 但是也留下了沉重的历史包袱，我们没有办法详细介绍make的每一个详细知识点(也没有必要)，我们总结了80%常用的Makefile知识点，定位在为以后研究Uboot、Linux kernel和其他开源项目打下结实的基础。 虽然这个目标难度还是比较大的，要学习的知识点也不少，不过我们会通过一系列难度逐步迭代的小实验， 来帮助大家无痛学会Makefile。

我一直提倡学习知识之前，要现在脑海中初步建立知识点的整体框架，以此来指导进一步的学习。 接下来我们先整体看一下要学习Makefile的知识点：

1. 基础语法： 描述目标和依赖的特定格式，Makefile的核心。
2. 变量：记录特定的信息，避免重复输入原始信息。尤其是手动输入原始信息很长时，特别好用。
3. 分支判断： 灵活控制多个不同的编译过程，方便兼容不同属性。
4. 头文件依赖： 监控头文件的变化，头文件也是程序的关键内容。
5. 隐含规则：利用Makefile的一些默认规则，可以减少编写Makefile的工作量。
6. 自动化变量：利用Makefile的默认的自动化变量，可以减少编写Makefile的工作量。
7. 模式规则： 灵活使用正则表达式，可以减少编写Makefile的工作量。
8. 函数：使用Makefile的各种函数，可以更方便地实现Makefile的功能。

了解完Makefile的知识点，从上面的分析可以知道，Makefile的核心在于基础语法，用来描述目标和依赖的关系。 其他语法的目的，是为了减少我们编写Makefile工作量，让我们能够以更加优雅、更加简洁、更好维护的方式来实现Makefile的功能。 这跟我们程序开发是很相似的，不止要实现功能，还要兼顾程序的可读性、拓展性、可维护性等等。

**真正开始**

在开始之前，介绍两本学习资料：

- 《跟我一起写Makefile》：这是中文版的，中国人自己写的！
- GNU官方的make说明文档：https://www.gnu.org/software/make/manual，当然是面面俱到无所不包，但是是英文文档，而且叙述严谨，需要有一定的基础才能看！

当然，再次建议先学完本章内容建立一个感性的认识之后再去阅读那两本书，否则只能打击学习兴趣（归根到底make语法实在太晦涩难懂了）！！

在路径`/home/lbd/repo/MGY_Gcb_linux/linux_ws/makefile_test/part_1`下创建一个文件`Makefile`，文件名不要乱取！

使用编辑器打开这个问价并输入以下内容：**注意命令前有<tab>**

```makefile
#创建目标targeta，该目标依赖于targetb与targetc，该目标执行的命令是ls -lh
targeta:targetb targetc
	ls -lh
	
#创建目标targetb，该目标执行命令pwd
targetb:
	pwd
	
#创建目标targetc，该目标执行命令使用touch创建text.txt文件
targetc:
	touch text.txt
	
#创建目标targetd，该目标执行命令删除text.txt文件
targetd:
	rm -f text.txt
```

这个Makefile文件主要是定义了四个目标 操作，先大致了解它们的关系：

- targeta：这是Makefile中的第一个目标代号，也是Makefile文件的最终目标，在符号“:”后 面的内容表示它依赖于targetc和targetb目标，它自身的命令为“ls -lh”，列出当前目录下的内容。
- targetb：这个目标没有依赖其它内容，它要执行的命令为“touch test.txt”，即创建一个test.txt文件。
- targetc：这个目标同样也没有依赖其它内容，它要执行的命令为“pwd”，就是简单地显示当前的路径。
- targetd：这个目标无依赖其它内容，它要执行的命令为“rm -f test.txt”，删除 目录下的test.txt文件。与targetb、c不同的是，没有任何其它目标依赖于targetd，而且 它不是默认目标。

下面使用这个Makefile执行各种make命令，对比不同make命令的输出，可以清楚地了解Makefile的机制：

```shell
#查看当前目录的内容
ls

#执行make命令，make会在当前目录下搜索“Makefile”或“makefile”，并执行
make

#可看到make命令后的输出，它执行了Makefile中编写的命令

#查看执行make命令后的目录内容，多了test.txt文件
ls

#执行Makefile的targetd目标，并查看，少了test.txt文件
make targetd
ls

#执行Makefile的targetb目标，并查看，又生成了test.txt文件
make targetb
ls

#执行Makefile的targetc目标
make targetc
```

相信此时你在终端下输入以上那些命令之后已经看到各种各样的输出结果了，现在对结果说明如下：

**make命令：**

- 在终端上执行make命令时，make会在当前目录下搜索名为“Makefile”或“makefile”的文件，然后 根据该文件的规则解析执行。如果要指定其它文件作为输入规则，可以通过“-f”参数指定输 入文件，如“make -f 文件名”。

  *直接使用make不指定文件名，make会默认寻找当前目录下名为Makefile或者makefile的文件，或者通过指定文件名的方式使用make*

- 此处make命令读取我们的Makefile文件后，发现targeta是Makefile的第一个目标，它会被当成默认目标执行。
- 又由于targeta依赖于targetc和targetb目标，所以在执行targeta自身的命令之前，会先去完成targetc和targetb。
- targetc的命令为pwd，显示了当前的路径。
- targetb的命令为touch test.txt ，创建了test.txt文件。
- 最后执行targeta自身的命令ls -lh ，列出当前目录的内容，可看到多了一个test.txt文件。

**make targetd、make targetb、make targetc命令：**

由于targetd不是默认目标，且不被其它任何目标依赖，所以直接make的时 候targetd并没有被执行，想要单独执行Makefile中的某个目标，可以使用”make 目标 名“的语法，例如上图中分别执行了”make targetd“ 、”make targetb“ 和”make targetc“指令，在执行”make targetd”目标时，可看到它的命令rm -f test.txt被执行，test.txt文件被删除。

**从这个过程，可了解到make程序会根据Makefile中描述的目标与依赖关系，执行达成目标需要的shell命令。简单来说，Makefile就是用来指导make程序如何干某些事情的清单。**

**引入Makefile来编译程序**

在路径`/home/lbd/repo/MGY_Gcb_linux/linux_ws/makefile_test/part_1`下创建四个文件：hello_main.c、hello_func.c、hello_func.h、Makefile，分别在前三个文件输入以下内容，Makefile文件留作以后待用：

```c
/*hello_func.c文件*/
#include <stdio.h>
#include "hello_func.h"

void hello_func(void)
{
	printf("hello world!\r\n");
}

```

```c
/*hello_main.c*/
#include "hello_func.h"

int main()
{
	hello_func();
	return 0;
}
```

```c
/*hello_func.h*/
void hello_func(void);
```

如果我们直接使用GCC进行编译，需要使用如下命令：

```shell
#注意最后的"-I ."包含名点"."
gcc -o hello_main hello_main.c hello_func.c -I .

#运行生成的hello_main程序
./hello_main
```

相对于基础的hello.c编译命令，此处主要是增加了输入的文件 数量，如“hello_main.c”、“hello_func.c”，另外新增的“-I .”是告诉编 译器头文件路径，让它在编译时可以在“.”（当前目录）寻找头文件。

那么在这里已经能直观地感受到当文件数量越多的时候，以这种方式来编译工作量也就越大，而且也很容易出错！

可以想像到，只要把gcc的编译命令按格式写入到Makefile，就能直接使用make编译，而不需要每次手动直接敲gcc编译命令。

在Makefile文件中输入如下命令;

```makefile
#默认目标
#hello_main依赖于hello_main.c和hello_func.c文件
hello_main:hello_main.c hello_func.c
	gcc -o hello_main hello_main.c hello_func.c -I .

#clean目标，用来删除编译生成的文件
clean:
	rm -f *.o hello_main
```

该文件定义了默认目标hello_main用于编译程序，clean目标用于删除 编译生成的文件。特别地，其中hello_main目标名与gcc编译生成的文件名”gcc -o hello_main”设置成一致了，也就是说，此处的目标hello_main在Makefile看来，已经是一个目标文件hello_main。

这样的好处是make每次执行的时候，会检查hello_main文件和依赖文件hello_main.c、hello_func.c的修改日期，如果依赖文件的修改日期比hello_main文件的日期新，那么make会执行目标其下的Shell命令更新hello_main文件，否则不会执行。

然后在终端上运行如下命令：

```shell
#使用make根据Makefile编译程序
make
ls

#执行生成的hello_main程序
./hello_main

#再次make，会提示hello_main文件已是最新
make

#使用touch命令更新一下hello_func.c的时间
touch hello_func.c

#再次make，由于hello_func.c比hello_main新，所以会再编译
make
ls
```

相信你已经在你的终端中去实验以及验证了，有了Makefile后，我们实际上只需要执行一下make命令就可以完成 整个编译流程。

下面我们再总结一下Makefile中跟目标相关的语法：

[目标1]：依赖

<tab>[命令1]

<tab>[命令2]

<tab>[...]

<tab>[命令n]

[目标2]：依赖

<tab>[命令1]

<tab>[命令2]

<tab>[...]

<tab>[命令n]

**目标：**指make要做的事情，可以是一个简单的代号，也可以是目标文件，需要顶格书写，前面不能有空格或Tab。一个Makefile可以有多个目标，写在最前面的第一个目标，会被Make程序确立为 “默认目标”，例如前面的targeta、hello_main。

**依赖：**要达成目标需要依赖的某些文件或其它目标。例如前面的targeta依赖 于targetb和targetc，又如在编译的例子中，hello_main依赖于hello_main.c、hello_func.c源文件，若这些文件更新了会重新进行编译。

**命令x**：make达成目标所需要的命令。只有当目标不存在或依赖文件的修改时间比目标文件还要新时，才会执行命令。要特别注意命令的开头要用“Tab”键，不能使用空格代替，有的编辑器会把Tab键自动转换成空格导致出错，若出现这种情况请检查自己的编辑器配置。

**伪目标：**前面我们在Makefile中编写的目标，在make看来其实都是目标文件，例如make在执行的时候由于在目录找不到targeta文件，所以每次make targeta的时候，它都会去执行targeta的命令，期待执行后能得到名为targeta的 同名文件。如果目录下真的有targeta、targetb、targetc的文件，即假如目标文件和依 赖文件都存在且是最新的，那么make targeta就不会被正常执行了，这会引起误会。

为了避免这种情况，Makefile使用“.PHONY”前缀来区分目标代号和目标文件，并且这种目标代号被称为“伪目标”，phony单词翻译过来本身就是假的意思。

也就是说，只要我们不期待生成目标文件，就应该把它定义成伪目标，前面的演示代码修改如下：

```shell
#默认目标
#hello_main依赖于hello_main.c和hello_func.c文件
hello_main: hello_main.c hello_func.c
   gcc -o hello_main hello_main.c hello_func.c -I .
#clean伪目标，用来删除编译生成的文件
.PHONY:clean
clean:
   rm -f *.o hello_main
```

GNU组织发布的软件工程代码的Makefile，常常会有类似以上代码中定义的clean伪目标，用于清除编译的输出文件。常见的还有“all”、“install”、“print”、“tar”等分别用于编译所有内容、安装已编译好的程序、列出被修改的文件及打包成tar文件。虽然并没有固定的要求伪目标必须用这些名字，但可以参考这些习惯来编写自己的Makefile。

如果以上代码中不写“.PHONY:clean”语句，并且在目录下创建一个名为clean的文件，那么当 执行“make clean”时，clean的命令并不会被执行，感兴趣的可以亲自尝试一下。

**默认规则：**make在执行时的流程

![image-20201108224732286](/home/lbd/repo/MGY_Gcb_linux/Documents/Embedded linux development.assets/image-20201108224732286.png)

不过在Makefile的实际应用中，通常会把编译和最终的链接过程分开。

这是因为，我们的hello_main目标文件本质上并不是依赖hello_main.c和hello_func.c文件，而是依 赖于hello_main.o和hello_func.o，把这两个文件链接起来就能得到我们最终想要的hello_main目标文件。另外，由于make有一条默认规则，当找不到xxx. o文件时，会查找目录下的同名xxx.c文件进行编译。根据这样的规则，我们可把Makefile改修改如下：

```makefile
hello_main:hello_main.o hello_func.o
	gcc -o hello_main hello_main.o hello_func.o
	
#以下是make的默认规则，下面四行可以不写
#hello_main.o: hello_main.c
# gcc -c hello_main.c
#hello_func.o: hello_func.c
# gcc -c hello_func.c
```

以上代码把依赖文件由C文件改成了.o文件，gcc编译命令也做了相应的修改，分别是hello_main.o文件和hello_func.o文件的依赖和编译命令，不过由于C编译成同名的.o文件是make的默认规则，所以这部分内容通常不会写上去。

在终端中使用make命令，然后查看输出信息。

从make的输出可看到，它先执行了两条额外的“cc”编译命令，这是由make默认规则执行的，它们把C代码编译生成了同名的.o文件，然后make根据Makefile的命令链接这两个文件得到最终目标文件hello_main。

**使用C自动编译成.o的默认规则有个缺陷，由于没有显式地表示.o依赖于.h头文件，假如我们修改了头文件的内容，那么.o并不会更新，这是不可接受的。并且默认规则使用固定的“cc”进行编译，假如我们想使用ARM-GCC进行交叉编译，那么系统默 认的“cc”会导致编译错误。**

要解决这些问题并且让Makefile变得更加通用，需要引入变量和分支进行处理。

**变量：**在Makefile中的变量，有点像 C语言的宏定义，在引用变量的地方使用变量值进行替换。变量的命名可以包含字符、数字、下划线，区分大小写，定义变量的方式有以下四种：

- = ：延时赋值，该变量只有在调用的时候，才会被赋值；
- := ：直接赋值，与延时赋值相反，使用直接赋值的话，变量的值定义时就已经确定了；
- ?= ：若变量的值为空，则进行赋值，通常用于设置默认值；
- += ：追加赋值，可以往变量后面增加新的内容。

当我们想使用变量的时候，语法为`$(变量名)`，接下来使用变量对`part_2`的makefile进行改造，新创建一个`part_4`，输入内容如下所示：

```makefile
#定义变量
CC=gcc
CFLAGS=-I.
DEPS = hello_func.h

#目标文件
hello_main: hello_main.o hello_func.o
   $(CC) -o hello_main hello_main.o hello_func.o

#*.o文件的生成规则
%.o: %.c $(DEPS)
   $(CC) -c -o $@ $< $(CFLAGS)

#伪目标
.PHONY: clean
clean:
   rm -f *.o hello_main
```

- 定义了CC、CFLAGS、DEPS变量，变量的值就是等号右侧的内容，定义好的变量可通过”$(变量名)”的形式引用，如后面 的”$(CC)”、”$( CFLAGS)”、”$(DEPS)”等价于定义时赋予的变量值”gcc”、"-I."和“hello_func.h”；
- 使用$(CC)替代了gcc，这样编写的Makefile非常容易更换 不同的编译器，如要进行交叉编译，只要把开头的编译器名字修改掉即可；
- ”%”是一个通配符，功能类似”*”，如”%.o”表示所 有以”.o”结尾的文件。所以”%.o:%.c”在本例子中等价 于”hello_main.o: hello_main.c”、”hello_func.o: hello_func.c”，即等价于o文件依赖于c文件的默认规则。不过这行代码后面的”$(DEPS)”表示它除了 依赖c文件，还依赖于变量”$(DEPS)”表示的头文件，所以当头文件修改的话，o文件也会被重新编译；
- 这行代码出现了特殊的变量”$@”，”$<”，可理解为Makefile文件保 留的关键字，是系统保留的自动化变量，”$@”代表了目标文件，”$<”代表了第一个依赖 文件。即”$@”表示”%.o”，”$<”表示”%.c”；

**改造链接规则：**与*.o文件的默认规则类似，我们也可以使用变量来修改生成最终目标 文件的链接规则，具体参考如下代码：

```makefile
#定义变量
TARGET=hello_main
CC=gcc
CFLAGS=-I.
DEPS=hello_func.h
OBJS=hello_main.o hello_func.o

#默认目标
$(TARGET):$(OBJS)
	$(CC) -o $@ $^ $(CFLAGS)

#*.o文件的生成规则
%.o:%.c $(DEPS)
	$(CC) -c -o $@ $< $(CFLAGS)

#伪目标
.PHONY:clean
clean:
	rm -f *.o hello_main
```

以上代码中的Makefile把编译及链接的过程都通过变量表示出来了，非常通用，使用这样的Makefile可以针对不同的工程直接修改变量的内容就可以使用。

其它的自动化变量：

| 符号 | 含义                                           |
| ---- | ---------------------------------------------- |
| $@   | 匹配目标文件                                   |
| $%   | 与$@类似，但$%仅匹配“库”类型的目标文件         |
| $<   | 依赖中的第一个目标文件                         |
| $^   | 所有的依赖目标，如果依赖中有重复的，只保留一份 |
| $+   | 所有的依赖目标，即使依赖中有重复的也原样保留   |
| $?   | 所有比目标要新的依赖目标                       |

**使用分支**

为方便直接切换GCC编译器，我们还可以使用条件分支增加切换编译器 的功能。在Makefile中的条件分支语法如下：

```makefile
ifeq(arg1, arg2)
分支1
else
分支2
endif
```

分支会比较括号内的参数“arg1”和“arg2”的值是否相 同，如果相同，则为真，执行分支1的内容，否则的话，执行分支2 的内容，参 数arg1和arg2可以是变量或者是常量。

**使用函数：**在更复杂的工程中，头文件、源文件可能会放在二级目录，编译生成的.o或可执行文件也放到专门的编译输出目录方便整理。示例中.h头文件放在includes目录下，.c文件放在sources目录下，不同平台的编译输出分别存放在build_x86和build_arm中。

在Makefile中调用函数的方法跟变量的使用 类似，以“$()”或“${}”符号包含函数名和参数，具体语法如下：

```makefile
$(函数名 参数)
#或者使用花括号
${函数名 参数}
```

下面以常用的notdir、patsubst、wildcard函数为例 进行讲解，并且示例中都是我们后面Makefile中使用到的内容。

**notdir函数**：notdir函数用于去除文件路径中的目录部分。它的格式如下：

```makefile
$(notdir 文件名)
```

例如输入参数“./sources/hello_func.c”，函数执行后 的输出为“hell_func.c”，也就是说它会把输入中的“./sources/”路径部分去掉，保留 文件名。

**wildcard函数：**用于获取文件列表，并使用空格分隔开。它的格式如下：

```makefile
$(wildcard 匹配规则)
```

例如函数调用“$(wildcard .c)”，函数执行后会把当前目录的所 有c文件列出。

**patsubst函数：**patsubst函数功能为模式字符串替换。它的格式如下

```makefile
$(patsubst 匹配规则, 替换规则, 输入的字符串)
```

当输入的字符串符合匹配规则，那么使用替换规则来替换字符串，当匹配规则中有“%”号时，替换规 则也可以例程“%”号来提取“%”匹配的内容加入到最后替换的字符串中。



#### 1.7 开始使用Git管理项目

写起来太麻烦了，推荐一个学习Git的网站，浅显易懂，非常厉害！！！

廖雪峰Git教程：https://www.liaoxuefeng.com/wiki/896043488029600



### 第二章  Linux系统编程



### 第三章  i.MX6ULL与NXP的介绍



## 第二部分 驱动开发

从这里开始正式讲述开发里的各方各面，这一部分内容摘要如下：

- 从传统的裸机开发开始，熟悉芯片功能开发
- 从裸机开发过渡到驱动开发，讲述两者异同点
- 立项，根据项目要求进行项目架构
- 移植uboot，移植Linux内核，分析移植过程与源码
- 针对项目开发驱动程序



### 第一章  开发环境的搭建



### 第二章  一切从裸机开始



### 第三章  分析项目需求与项目规划



### 第四章  uboot与内核



### 第五章  驱动程序开发



## 第三部分 应用开发

至此到最后一部分了，这一部分在前面开发驱动程序的基础上，既然驱动程序已经开发起来了，相当于房子已经做好了，接下来就是按自己需求买家具，所以这一部分就是按需求开发应用程序，在嵌入式Linux里面叫做特定场景功能的应用程序开发，本部分内容如下：

- 移植QT与分析
- 代码的设计模式
- 用C++开发自己的第一个应用程序
- 分析项目需求，根据特定场景设计应用程序功能
- TCP/IP还是MQTT？
- 