# 嵌入式Linux开发

## 第一部分 Linux基础

Linux版本选择Ubuntu18.04，安装教程：**谷歌搜索**

### 第一章  熟悉Linux系统

Ubuntu18.04安装完成后，为了方便以后在嵌入式移动设备上的开发，必须熟悉Linux系统的使用环境。

**本章内容摘要如下：**

- 熟悉Linux系统，熟悉基本操作，了解相关概念。
- 学会vi/vim编辑器。
- 熟悉shell，学会shell编程。
- 熟悉Makefile，学会make工具构建项目。
- 熟悉Git，学会使用GitHub和Gitee管理项目。



*如何定制自己的Ubuntu与美化系统，最终打造一个MAC风格或其它类型的风格的桌面环境，在另一份教程里提到。*



#### 1.1  开始使用Linux

为什么强调需要在带桌面的图形界面上熟悉Linux系统？

- 将来接触的嵌入式Linux设备开发，是不带图形界面的，甚至连编译代码都系要在PC机上完成。
- 刚从Windows环境转来Linux，这两个系统有相同之处，但不同点也有很多，主要是体现在了操作方式上的不同以及概念上的不同。
- 尽快熟悉使用Linux，尽快投入项目开发环境中去。



##### 1.1.1 嵌入式Linux的相关概念

首先从Linux的使用场景说起。

生活中我们接触得最多的就是手机里的安卓或IOS系统，以及Windows，若不是相关的开发人员，可能都不会听说过Linux，但是Linux系统在生活中其实是随处可见的。我们的手机操作系统就是基于Linux内核开发的，但是不开源，随处可见的移动设备，终端机、服务器，甚至导弹上都是基于Linux开发起来的，所以从大方向上划分，Linux系统的应用场景可以分为两类：

- 服务器
- 嵌入式设备(可移动的和不可移动的)

既然Linux系统这么广泛，那与开发它相关的行业有那些呢？

1. 服务器运维：服务器基本都运行在Linux系统上，而管理与开发的从业人员则是服务器运维工程师。

2. 应用软件开发：类似与Windows的QQ、浏览器等等应用软件(application、简称App)，在Linux系统上也有许多应用软件，这些便是由Linux应用软件开发工程师开发的，关于应用软件开发也大致上分为以下三种：

   - 服务器应用软件开发；
   - 桌面应用软件开发；
   - 嵌入式应用软件开发。

   服务器应用软件开发，顾名思义，就是专门在服务器主机上跑的应用软件；桌面应用软件开发，我们平时接触到的电脑都属于桌面系统，是带显示屏的，而我们在桌面系统上运行的应用软件就属于这一类；嵌入式应用软件开发的方向主要是针对设备应用场景做针对性的开发，如扫地机器人、汽车导航仪以及我们公司想要开发的显示屏控制器。**但是十分注意的一个概念是，应用软件开发是不与硬件打交道的，即使是在嵌入式设备上开发APP，与它们打交道的是操作系统，即Linux。操作系统通过开放系统API来完成APP对硬件的特殊控制，或者硬件的数据和信息通过系统API向上提供给APP**

3. 设备驱动开发：本质也属于软件程序，与应用程序不同的是，它是介于硬件和操作系统之间，是硬件与操作系统之间的桥梁；而应用程序是介于人与操作系统之间。简单粗暴的理解则是驱动程序就是STM32裸机开发里的那种设备初始化代码(BSP)，但实际上比裸机开发复杂得多，因为要与操作系统交互。下图显示了这样的层次关系：

![image-20201104140726058](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104140726058.png)

对于不使用操作系统或使用小型实时操作系统（如freeRTOS）的设备来说，与硬件相关的驱动程序与应用程序往往混合在一起，因此常常不会对驱动与应用进行严格的区分，这也导致更换硬件平台时，应用程序移植困难。

使用了Linux系统的设备，硬件会由操作系统接管。Linux系统的一个重要设计哲学是一切皆文件。包括硬件设备，对于系统来说也是一个文件，所以系统向上层应用程序提供open、write、read、close等统一的文件操作接口，应用程序可以利用这些接口对设备文件进行访问，从而实现对硬件设备的初始化、写入、读取以及关闭等操作。

**当系统接收到应用程序的这些访问请求时，它会向下查询对应设备具体的操作函数，然后调用相应的函数处理请求，而这些针对不同设备具体的操作函数就是设备驱动程序**。因此，设备驱动就是这样一种把硬件与操作系统连接在一起的程序，Linux系统会提供统一的格式，设备驱动开发工程师根据具体的设备按照系统格式要求实现相应的设备操作函数。**由此可见设备驱动开发相比于以往STM32裸机开发的复杂之处**。



##### 1.1.2 Linux的文件系统

相信你在安装完Ubuntu系统后已经开始操作体验了，图形化的界面上操作与Windows有许多相同之处，但是对于第一次使用的用户来说却总是显得那么不习惯，甚至格格不入到最后放弃，这其实都是来源于对未知的恐惧与消极的探索心里，最后放弃探索回到熟悉得不能再熟悉的Windows上找回存在感。

其实只要了解了相关的概念之后，Linux一点也不难，甚至对用户很友好，因为它是可以随意自由搭配与裁剪的，关于如何定制自己的Ubuntu，我在另一份文章里讲解，但是在看那份文章之前，请先把本章看完，熟悉相关概念与操作之后再去看。

**Linux文件系统：** *记住这一点概念，Linux里面一切皆文件，再结合以下讲解来理解*

打开文件夹，显示的目录是主目录，或者换另一种说法：家目录(home)，如下图所示：

![image-20201104150159766](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104150159766.png)

这个目录是当前登录用户的个人目录，用户对于在这个目录之下的所有文件有着一切权利(读改写与删除)，建议在通常情况下个人相关的内容也是保存在该目录中，因为其它目录大都是系统相关的，使用时容易导致混乱，而且需要相关权限。

上面提到的其它目录，如下图黄色方框：

![image-20201104151326387](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104151326387.png)

是在其它位置中的，与家目录区分开来，它叫根目录(root)，这是操作系统管理的目录，对所有用户都开放读权限(基本上)，而操作系统对这个目录下所有的文件拥有一切权利，其它用户包括登录用户需要授权才可以进行某些操作，称为操作受限的。

![image-20201104152009844](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104152009844.png)

根目录下不同的文件有着不同的功能，如bin目录里面存放的是可执行的二进制文件，即应用程序，boot目录存放的是操作系统启动相关的，一旦这个文件被破坏了就会造成操作系统异常，由此可见根目录下文件的重要性，所以这也就是为什么这里的文件对用户只开放了只读功能而不能修改它们，但是用户可以通过根用户授权的方式来进行修改操作，同时这种授权方式也提醒了用户所修改的文件是受保护的文件，应谨慎操作。这种个人与系统文件分割出来的方式大大提升了系统的稳定性与有序性，不容易造成安全隐患与混乱。

与此同时，在根目录下找到home目录，这就是我们所说的家目录，点击进去可以看到里面还有一个文件夹，如图所示：

![image-20201104152814176](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104152814176.png)

这个文件夹是用户目录，由于在我的系统里面只登录了一个用户，所以只有一个，如果有多个用户，就会有多个文件夹，再点进去就是我们的主目录了。

以上概念都是普通的Linux使用者了解了之后即可，但是对于Linux开发者来说，必须要深入了解Linux文件系统这一概念，这是因为在以后的系统移植中，需要构建这种文件系统。

**那么什么是Linux文件系统呢？**

如果从专业的角度说起会觉得晕头转向不知所云，那么便从简单说起，在上面的介绍中，我们知道了Linux最底层的目录是根目录，根目录之下有许多目录，如bin、root、etc、home等等，这是倒数第二层，而这一层除了home目录之外，都是系统运行或应用程序所组成的文件，暂时知道这些即可。再回头看home目录，我们知道它是属于用户的家目录，但是实际上现在的操作系统都是多任务多用户的操作系统，即系统使用者不仅仅只有一个而是可以有多个，关于多用户多任务操作系统这涉及另一个概念，现在只要知道即可，所以在home目录下应该有多个用户相关的目录，一个用户从属于一个目录，到了这里可以理解为第三层，对于这个home目录下的文件，当前登录用户只对它自己的目录有着至高无上的权利，而对其它目录都只能只读无法做其它操作，所以进入到自己对应的主目录后，这里理解为第四层，也就是普通Linux使用者平时接触得最多的一层。

以上按层次的分析很像一个倒着的树状结构，于是乎我们称之为目录树，这个目录树下每个目录或者说文件夹具体是什么内容，属于谁的，是做什么的，可不是随便定制的，它是由Linux文件系统规定的。Linux为了方便管理系统各个资源，制定了这么一套标准，用来说明这个目录必须得是这样的，那个目录必须得是那样的，比如boot必须得是存放与系统启动相关的东西，其它无关的东西不要放进来，而且连目录名字都不能乱取。

Linux文件系统，又称为文件层次标准(FHS)，是Linux系统为方便统一管理资源与文件而定制的标准，在Linux系统中，即使是硬件设备，也是被抽象成了文件，存放在根目录下的dev目录里面，这就对应上了在Linux里面一切皆文件的概念。

关于Linux层次标准这个文档，在Linux基金会官网可以下载，但是有五百多页，以下将简要列一个表格，介绍每个目录的内容与作用：

| 目录        | 内容                                                         |
| ----------- | ------------------------------------------------------------ |
| bin         | 存放系统命令的目录，二进制应用程序，如cd、ls、pwd等          |
| boot        | 存放开机启动过程所需的内容                                   |
| dev         | 所有设备文件的目录                                           |
| etc         | 系统的主要配置文件                                           |
| home        | 用户目录                                                     |
| lib         | 存放sbin和bin目录下命令所需的库文件                          |
| lib32/lib64 | 存放二进制函数库                                             |
| lost+found  | 在EXT3/4系统中，当系统意外崩溃或意外关机时，会产生一些碎片文件在这个目录下面，系统启动fcsk工具会检查这个目录，并修复已损坏的文件。 |
| media       | 用于挂载光盘或U盘                                            |
| mnt         | 与media一样                                                  |
| opt         | 第三方软件安装存放目录                                       |
| proc        | 进程以及内核信息存放目录，不占用硬盘空间                     |
| root        | root用户的目录                                               |
| run         | 是一个临时文件系统，存储系统启动以来的信息，当系统重启时，这个目录下的文件应该被删掉或清除。 |
| sbin        | root用户使用的命令存放目录                                   |
| srv         | 一些网络服务所需要的数据文件                                 |
| sys         | 同proc目录，用于记录CPU与系统硬件相关的信息                  |
| tmp         | 程序运行时产生的临时文件存储目录                             |
| usr         | 系统存放程序的目录                                           |
| var         | 存放内容经常变动的文件目录，如日志                           |

**Linux文件类型**

在Linux下，一切皆文件，但是文件是有类型区别的：

- 普通文件：文本文件、bin文件；
- 可执行文件：脚本、应用程序；
- 链接文件：类似于Windows里的快捷方式，链接文件又分为两类：
  - 硬链接：同一个文件的不同别名；
  - 软链接：链接文件里包含另一个文件的位置信息。
- 目录文件：Linux下一切皆文件，所以目录是文件也就不奇怪了；
- 设备文件：通过打开对应的设备文件可以初始化设备，部分设备还可以通过读写设备文件实现对硬件的控制。

文件有那么多类型，那怎么区分呢？

在Windows里面我们区分文件类型一般是通过文件扩展名来区分，如.exe结尾的是可执行文件。Linux下没有这个要求，但是为了兼容Windows的操作习惯，Linux也可以加入文件扩展名来区分文件类型：

- 后缀.tar、.tar.gz、.tgz、.zip、.tar.bz表示压缩文件，创建命令一般为tar，gzip，zip等。 在压缩文件中的后缀名来通常表示自身由什么压缩格式打包的，以便解压时方便选择要使用的命令。
- .sh表示shell脚本文件，通过shell语言开发的程序。
- .py表示python语言文件，通过python语言开发的程序。
- .html、.htm、.php、.jsp、.do表示网页语言的文件。
- .conf表示系统服务的配置文件。
- .deb表示deb安装包文件。



##### 1.1.3 多用户与文件权限

在早期的Windows操作系统，如Windows 95 和 Windows XP，都是单用户操作系统。 所谓的单用户操作系统，就是说在同一时间，只能由一个用户独自享用系统的全部硬件和软件资源。 我们现在所使用的win7、win8以及win10都是多用户操作系统，与单用户操作系统恰恰相反， 它支持多个用户能够同时访问和使用同一台计算机的全部硬件和软件资源。

在众多用户中，其中的一个用户administrator具有管理其他用户账号和计算机的全部资源的权限。 我们在安装软件的时候，经常会看到“要以管理员身份运行该软件”，又或者是如下图，实际上就是要求我们给予程序一些管理员的权限。

![image-20201104161146798](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104161146798.png)

Linux操作系统，同样也是多用户操作系统，其中具有管理其他用户和计算机的全部资源的用户，称为root。前面提及过安卓系统，实质上也是基于Linux，安卓手机上常常提到的root权限，也就是获取最高的权限， 就跟电脑获取超级管理员的权限是一样的。

在Linux中，每个用户都有一个特定的编号—UID，它是用于标识一个系统用户。Linux将标号0分配给root，它可以分配给每个用户不同的权限，因此每个用户可进行的操作也不同。

在命令行中输入`id`，可以查看当前用户的UID，如下图所示(按住ctrl+alt+t打开命令行)：

![image-20201104161728119](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104161728119.png)

红框是用户的id，可以看到其值为1000，这是root分配的id号，而黄色方框的gid用于标识当前用户所在的分组（Group），每个用户可以对应多个分组，就比如一个人在学校里面既可以属于学生会组织，也可以属于街舞社、绘画社等等。Linux系统拥有多个分组，每个用户分组就相当社团，用户如果是多个用户组的成员，就可以访问其他分组对应的文件， 前提是该分组的文件允许其他用户访问，这就需要了解另一个概念：文件权限。

在Windows系统中我们经常接触的文件属性，无非就是以下两种属性：只读、隐藏。从字面上的意思，我们也很好理解。具有只读属性的文件，我们不能对文件的内容进行修改。而具有隐藏属性的文件，我们一般情况下是看不到的。

Linux的文件属性，可以分为读权限、写权限、执行权限。读权限以及写权限，基本上和Windows操作系统是一样的。关于执行权限，是指可以加载到内存中，并由操作系统加载程序执行的文件。在Windows操作系统中， 我们接触最多的应该是后缀为.exe的文件。但是对于Linux来说，它并不是通过后缀名来识别文件类型的， 如果我们想要执行某个可执行文件，则需要为其添加执行权限，即勾选前面的“允许作为程序可执行文件”。

![image-20201104162709833](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104162709833.png)

除此之外，关于Linux文件权限，还需要分三种情况：文件拥有者（owner），分组成员（groups）以及其他分组成员（other）。 如上图中的文件拥有者我，即当前登录用户对该文件的内容可以进行读写操作， 而对于当前登录用户分组以及其他分组的用户则只能阅读该文件，并不能对该文件进行修改。 如果我们想修改其他分组的文件，我们可以修改该文件分组所拥有的权限。



#### 1.2 开始使用命令行

上面的介绍都是以图形桌面的方式来介绍的，可以看到图形桌面对用户很友好而且也很方便使用，但是为什么还需要熟悉使用这种这么**不方便的‘(?)’**命令行操作呢？

- 在Linux系统里面有很多程序不提供界面操作，为了使用它们只能通过命令行方式；
- Linux文件权限的限制，图形界面的操作只能操作有限的事物，而命令行的方式通过使用根用户权限来操作一切；
- 在以后的开发中，嵌入式平台不提供界面操作，为了尽快融入开发环境，必须的熟悉命令行操作。

以上的三点原因可能不完善，因为在Linux里面使用命令行的理由实在太多了，除此之外，命令行即终端，两者意思一样，英文叫terminal，所以称呼为终端更合适！

在第一句话中，我在不方便后面打了个问号，实际上不方便只是相对的，在熟悉使用了Linux之后，这种不方便的感觉便会消失，实际上操作Linux系统，终端操作是最方便而且效率是最高的！



##### 1.2.1 终端的概念

早期的Unix系统与用户就是通过Shell进行交互的，如下图所示，Shell对外接受用户输入的命令， 对内通过“系统调用”传递给内核，内核执行操作后把输出通过Shell呈现给用户，也就是说， Shell就是一个中间人。而Shell的英文原意“壳”，也是为了把它与内核区分开来。

![image-20201104164916337](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104164916337.png)

那么上面的shell与终端有什么关系呢？

实际上新学者很容易误解为shell就是终端，其实严格意义上，它们有着各自的概念：

- shell：指命令行解释器，常见的解释器有bash、sh、dash等等，在Ubuntu系统中默认用的是bash解释器，所以有时说bash也是指命令行。
- 终端：通常指用来运行Shell的程序。



##### 1.2.2 终端的使用

在Linux系统中，打开终端有两种方式：

- 快捷键`ctrl + alt + t`即可打开，这种打开方式终端会默认定位到用户主目录；
- 鼠标右键选择打开(如下图所示)：这种打开方式可以在任意文件夹下都可以使用，而且在不同的文件夹下打开终端后会自动定位到该文件夹的路径，在桌面打开的话会默认定位到用户主目录。

![image-20201104165748468](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104165748468.png)

**命令提示符：**如图所示

![image-20201104165922217](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104165922217.png)

打开终端后，我们可以看到终端本身显示了一行字符，而且按回车后会重复出现：

实际上这行提示符分成以下几个部分：

- lbd：“@”符号的左侧，它表示的是当前登录用户；
- @：分隔符号，可理解为at，表示lbd用户在主机上登录；
- lbd-Gcb：当前系统的主机名；
- 冒号：分隔符；
- ~：冒号后表示用户当前所在的目录，此处的波浪线表示当前用户的家目录，即“~”的含义为/home/lbd目录；
- $：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是“#”，如果是普通用户，提示符就是“$”。

**开始使用：**

请亲自尝试在终端中输入如下命令，注意如果使用了中文输入法的话，要记得把它切换回英文模式。 另外，在以下命令中的波浪号“~”也是英文符号，还要注意终端中所有的内容都是区分大小写的：

```shell
cd /home	 # 切换到/home目录
pwd				   # 显示当前目录
cd ~				 # 切换至~目录
pwd
ls						# l是字母L的小写，不要把l输入成数字1或字母i的大写
ls -l
```

输入后的结果如下：

![image-20201104171802228](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104171802228.png)



##### 1.2.3 常用命令与帮助

通过以上的一些命令示例，我们大致可以归纳命令的格式：

```shell
command [-optional] [arguments]
```

命令的组成一般分三部分，每部分之间使用空格隔开，说明如下：

- command：命令名，如前面的cd命令，pwd命令，ls命令；
- -optional：命令的选项，使用“-”开头的或“–”开头，如前面示例“ls -l”中的-l选项， 命令会根据具体的选项执行不同的操作。使用“-”时一般是选项的简写， 一些选项可以同时使用，“ls -la”等价于“ls -l -a”，即同时使用“l”和“a”选项。 而“–”一般后面带选项的全名，如“ls -a”等价于“ls –all”；
- arguments：命令参数，如前面cd命令中以“/home”和“~”参数作为路径名。

*注意：以上的中括号代表的是可选的，即不是必要输入的！！！*

那么Linux命令有那么多，还有选项，有着许多种组合，这实在难以记忆，怎么可能方便使用呢？

其实可以灵活使用终端的帮助功能：

1. 每个命令都会带有一个“-h” 或者“–help”的参数，可以用来打印一些帮助说明。 比如，如果现在不知道ls的选项a有什么用法，那么就可以执行下面的命令：

   ```shell
   ls --help
   ```

   ![image-20201104172558665](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104172558665.png)

   从上图中圈出来的地方，可以知道参数a可以只列出隐藏的内容。

2. 灵活使用Tab键自动补全，假如我们知道有个命令是以“whic”开头，但想不起全称， 那么我们可以在终端输入“whic”然后按一下“Tab”键，它会自动补全命令为“which”。如果我们只记得命令是以“wh”开头的话，按一下“Tab”键发现它没反应（如果接入了耳机可以听到一下提示音），这时我们尝试按两下“Tab”键，终端输出了好多以“wh”开头的命令，如which，who，whoami等。所以按一下“Tab”键时如果只有一个匹配的内容时它会自动补全，按两下“Tab”键则会列出所有的匹配项。“Tab”键除了用来补全命令名，还可以自动补全路径，如我们使用cd命令输入“/home”参数时， 先输入“/ho”然后按下“Tab”键，它会把“/ho”自动补全为“/home”路径名，如下图所示。这在使用命令行时是频繁使用的技巧，能减少我们的输入，而且不容易出错。

3. 在应用中我们有时会想要中止命令的执行，或者命令输入到一半的时候觉得输错了不想继续， 这时我们都可以通过“Ctrl”+“c”的组合键来结束。

4. 使用man命令。除了–help选项外，Linux还提供了一个man命令，可用于查看Linux系统自带的参考手册，该手册包含非常丰富的内容， 甚至在我们进行编程开发时还可以使用它来查看函数的接口。

   其使用格式为：

   ```shell
   man [要查询的内容]
   如：
   man ls
   ```

   ![image-20201104173626557](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201104173626557.png)

   按键盘方向键的“↑”“↓”键可以实现画面上下滚动，按键盘的“Page Up”和“Page Down”键可以上下翻页，按“q”键退出手册。

   关于man手册本身的使用，可以使用如下命令查看：
   
   ```shell
   man man 
   ```
   
   ![image-20201105090220647](/home/lbd/文档/linux学习笔记/嵌入式Linux开发学习笔记.assets/image-20201105090220647.png)
   
   从上图可了解到，除了Shell命令外，还可以看到man手册支持共9种类型的内容，如第一章是关于Shell命令， 第二章是系统调用（内核提供的函数）、第三章是库调用（程序库中的函数）等等。
   
   以下表格列出一些常用命令以及它的使用说明：
   
   | 命令  | 使用说明与格式                                               |
   | ----- | ------------------------------------------------------------ |
   | cd    | cd [目录名]：切换目录使用                                    |
   | mkdir | mkdir [-p] 目录名                                            |
   | touch | touch 文件名                                                 |
   | ls    | ls [选项] [目录]                                             |
   | cat   | cat 文件名                                                   |
   | echo  | echo命令的功能是在终端上打印一段文字，也可以把终端 的变量内容打印出来 |
   |       |                                                              |
   |       |                                                              |
   |       |                                                              |
   
   

#### 1.3  软件安装与管理

首先理解软件安装的几个概念：

- 二进制文件安装；
- 源码编译安装；
- 自动化工具安装

在windows操作系统中，我们要想安装某个软件的时候，只要点开相应的exe文件，一直按“下一步”，最后点“完成”， 这样就可以在我们电脑上使用这个软件了。而在Ubuntu系统中提供了一个软件商店，虽然它也可以提供软件的下载， 并且能够自动安装，但是有些软件并不一定能够在里面搜索得到，那只能以源码的方式来安装软件。采用源码的安装方式， 都需要检测当前的系统环境，设置编译的参数，如加入/剔除某个模块等，这样的安装方式就显得非常的繁琐。

目前，大多数类Unix 操作系统都提供了一种中心化的机制用来搜索和安装软件，软件开发者先在固定的硬件平台上将需要安装或升级的软件编译好， 然后再将软件的所有相关的文件打包存放在公开的服务器中。用户想要安装某个软件时，通过包的形式进行分发，包提供了操作系统的基本组件， 以及共享的库、应用程序、服务和文档，当用户需要时，可以运行特定的指令来安装。负责这部分工作内容的工具被称为包管理工具， 包管理工具除了安装软件外，它还负责更新已经安装的包。

在Linux操作系统中，最常见的两种包分别是deb和rpm。



#### 1.4 使用文本编辑器vi/vim





#### 1.5 熟悉shell与shell编程





#### 1.6 使用make工具构建项目

为什么要学习make？

原因：uboot、Linux内核、自己编写的驱动程序等等，有许多源文件，这些源文件如果自己一个一个手动编译和链接，绝对能累死，这时候我们就需要一种自动化的构建工具，这种工具能根据我们的要求来编译链接然后生成可执行文件，所以make就出现了。事实上，在Windows系统开发项目的时候使用的那些IDE，也叫集成开发环境，可以很方便的帮我们管理项目，自动编译文件，而用户只需要关心代码即可，但是IDE的本质也是像make工具一样在帮我们工作，只不过IDE有着友好的图形界面，自动的帮助我们配置好编译环境。那么为什么到Linux下开发就不用IDE了呢？**因为没有**，其实大多数IDE都是收费的，Linux的宗旨就是开源免费，收费的IDE与免费开源的理念不同导致它们走不到一块去，所以Linux上面就没有这些好用的IDE了。

现在知道了必须要使用make工具的原因了，再补充一点，学习make工具是非常有必要而且很有用的，作为对程序员来说是一个知识层次上的升华，可以深入了解编译器工作的原理。

既然如此，在学习make工具之前，首先深入了解一下一个C语言源文件是怎么被编译成一个二进制的可执行文件的就很有必要了！



##### 1.6.1  GCC与Hello World！





#### 1.7 开始使用Git管理项目

写起来太麻烦了，推荐一个学习Git的网站，浅显易懂，非常厉害！！！

廖雪峰Git教程：https://www.liaoxuefeng.com/wiki/896043488029600



### 第二章  Linux系统编程



### 第三章  i.MX6ULL与NXP的介绍



## 第二部分 驱动开发

从这里开始正式讲述开发里的各方各面，这一部分内容摘要如下：

- 从传统的裸机开发开始，熟悉芯片功能开发
- 从裸机开发过渡到驱动开发，讲述两者异同点
- 立项，根据项目要求进行项目架构
- 移植uboot，移植Linux内核，分析移植过程与源码
- 针对项目开发驱动程序



### 第一章  开发环境的搭建



### 第二章  一切从裸机开始



### 第三章  分析项目需求与项目规划



### 第四章  uboot与内核



### 第五章  驱动程序开发



## 第三部分 应用开发

至此到最后一部分了，这一部分在前面开发驱动程序的基础上，既然驱动程序已经开发起来了，相当于房子已经做好了，接下来就是按自己需求买家具，所以这一部分就是按需求开发应用程序，在嵌入式Linux里面叫做特定场景功能的应用程序开发，本部分内容如下：

- 移植QT与分析
- 代码的设计模式
- 用C++开发自己的第一个应用程序
- 分析项目需求，根据特定场景设计应用程序功能
- TCP/IP还是MQTT？
- 